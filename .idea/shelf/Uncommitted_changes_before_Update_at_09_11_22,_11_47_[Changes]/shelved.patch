Index: 04ex_numpy.ipynb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"1\\\\. **Reductions**\\n\",\n    \"\\n\",\n    \"Find the total mean, and the mean for each row and column of the following matrix:\\n\",\n    \"\\n\",\n    \"```python\\n\",\n    \"m = np.arange(12).reshape((3,4))\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"2\\\\. **Outer product**\\n\",\n    \"\\n\",\n    \"Find the outer product of the following vectors:\\n\",\n    \"\\n\",\n    \"```python\\n\",\n    \"u = np.array([1, 3, 5, 7])\\n\",\n    \"v = np.array([2, 4, 6, 8])\\n\",\n    \"```\\n\",\n    \"\\n\",\n    \"Use different methods to do this:\\n\",\n    \"\\n\",\n    \"   1. Using the function `outer` in numpy\\n\",\n    \"   2. Using a nested `for` loop or a list comprehension\\n\",\n    \"   3. Using numpy broadcasting operations\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"3\\\\. **Matrix masking**\\n\",\n    \"\\n\",\n    \"Create a 10 by 6 matrix of float random numbers, distributed between 0 and 3 according to a flat distribution.\\n\",\n    \"\\n\",\n    \"After creating the matrix, set all entries $< 0.3$ to zero using a mask.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"4\\\\. **Trigonometric functions**\\n\",\n    \"\\n\",\n    \"Use `np.linspace` to create an array of 100 numbers between $0$ and $2\\\\pi$ (inclusive).\\n\",\n    \"\\n\",\n    \"  * Extract every 10th element using the slice notation\\n\",\n    \"  * Reverse the array using the slice notation\\n\",\n    \"  * Extract elements where the absolute difference between the `sin` and `cos` functions evaluated for that element is $< 0.1$\\n\",\n    \"  * **Optional**: make a plot showing the sin and cos functions and indicate where they are close\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"5\\\\. **Matrices**\\n\",\n    \"\\n\",\n    \"Create a matrix that shows the 10 by 10 multiplication table.\\n\",\n    \"\\n\",\n    \" * Find the trace of the matrix\\n\",\n    \" * Extract the anti-diagonal matrix (this should be ```array([10, 18, 24, 28, 30, 30, 28, 24, 18, 10])```)\\n\",\n    \" * Extract the diagonal offset by 1 upwards (this should be ```array([ 2,  6, 12, 20, 30, 42, 56, 72, 90])```)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"6\\\\. **Broadcasting**\\n\",\n    \"\\n\",\n    \"Use broadcasting to create a grid of distances.\\n\",\n    \"\\n\",\n    \"Route 66 crosses the following cities in the US: Chicago, Springfield, Saint-Louis, Tulsa, Oklahoma City, Amarillo, Santa Fe, Albuquerque, Flagstaff, Los Angeles.\\n\",\n    \"\\n\",\n    \"The corresponding positions in miles are: 0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448\\n\",\n    \"\\n\",\n    \"  * Build a 2D grid of distances among each city along Route 66\\n\",\n    \"  * Convert the distances in km\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"7\\\\. **Prime numbers sieve**\\n\",\n    \"\\n\",\n    \"Compute the prime numbers in the 0-N (start with N=99) range with a sieve (mask).\\n\",\n    \"\\n\",\n    \"  * Constract a shape (N,) boolean array, which is the mask\\n\",\n    \"  * Identify the multiples of each number starting from 2 and set accordingly the corresponding mask element\\n\",\n    \"  * Apply the mask to obtain an array of ordered prime numbers\\n\",\n    \"  * Check the performances (with `timeit`); how does it scale with N?\\n\",\n    \"  * Implement the optimization suggested in the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"8\\\\. **Diffusion using random walk**\\n\",\n    \"\\n\",\n    \"Consider a simple random walk process: at each step in time, a walker jumps right or left (+1 or -1) with equal probability. The goal is to find the typical distance from the origin of many random walkers after a given amount of time.\\n\",\n    \"\\n\",\n    \"*Hint*: create a 2D array where each row represents a walker, and each column represents a time step.\\n\",\n    \"\\n\",\n    \"  * Take 1000 walkers and let them walk for 200 steps\\n\",\n    \"  * Use `randint` to create a 2D array of size $walkers \\\\times steps$ with values -1 or 1\\n\",\n    \"  * Calculate the walking distances for each walker (e.g. by summing the elements in each row)\\n\",\n    \"  * Take the square of the previously-obtained array (element-wise)\\n\",\n    \"  * Compute the mean of the squared distances at each step (i.e. the mean along the columns)\\n\",\n    \"  * **Optional**: plot the average distances ($\\\\sqrt(distance^2)$) as a function of time (step)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.8.5\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 2\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/04ex_numpy.ipynb b/04ex_numpy.ipynb
--- a/04ex_numpy.ipynb	(revision 7d0f9f170e29a440e46ac6651fc2b261d6d0464a)
+++ b/04ex_numpy.ipynb	(date 1667558387673)
@@ -15,10 +15,13 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
-   "source": []
+   "source": [
+    "import numpy as np\n",
+    "m = np"
+   ]
   },
   {
    "cell_type": "markdown",
@@ -42,7 +45,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
@@ -60,7 +63,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
@@ -81,7 +84,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
@@ -101,7 +104,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
@@ -124,7 +127,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
@@ -146,7 +149,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
@@ -171,7 +174,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
    "metadata": {},
    "outputs": [],
    "source": []
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1667506734877)
+++ b/.idea/vcs.xml	(date 1667506734877)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/ScientificComputingWithPython2022" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
